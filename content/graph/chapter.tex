\chapter{Graph}

\section{Fundamentals}
	\kactlimport{BellmanFord.h}
	\kactlimport{SPFA.h}
	\kactlimport{Shapes.h}

\section{Karp's minimal average cycle dp }
    \scalebox{0.75}{\parbox{\linewidth}{
		\begin{align*}
		H_0[v]=0 \quad
		H_{i+1}[v]=\min_{(u, v, W) \in G} H_i[u] + W \quad
		\min_{v \in G} \max_{0 \leq k < n} \frac{H_n[v]-H_k[v]}{n-k}
		\end{align*}
    }}

\section{Network flow}
	\kactlimport{EdmondsKarp.h}
	\kactlimport{PushRelabelKactl.h}
	\kactlimport{PushRelabel.h}
	\kactlimport{FlowDemands.h}
	\kactlimport{MinCostKFlowFast.h}
	\kactlimport{Dinic.h}
	% \kactlimport{MinCut.h}
	\kactlimport{GlobalMinCut.h}
	\kactlimport{GomoryHu.h}

\section{Flow with demands}
	% \vspace{20pt}
    \scalebox{0.8}{\parbox{\linewidth}{
    Say we want $d(e) \le f(e) \le c(e)$ for each edge.
    To find an arbitrary flow, add $s', t'$ and the following edges:
    \begin{itemize}
        \item $\forall v \in V: c'((s',v)) = \sum_u d((u,v)), \hspace{0.5cm} c'((v, t')) = \sum_w d((v,w))$,
        \item $\forall (u,v) \in E: c'((u,v)) = c((u,v)) - d((u,v))$,
        \item $c'((t,s)) = \infty$.
    \end{itemize}
    For min flow, replace $\infty$ with $L$ and find smallest $L$ such that flow is saturated.
    }}

\section{Matching}
	\kactlimport{hopcroftKarp.h}
	\kactlimport{TurboMatching.h} % spoko / do wytestowania
	\kactlimport{VertexCover.h}
    \kactlimport{BoskiMatching.h} % spoko / do wytestowania
	\kactlimport{WeightedMatching.h} % spoko / do wytestowania
	\kactlimport{GeneralMatching.h} % spoko / do wytestowania
	\kactlimport{WeightedBlossom.h}
    \kactlimport{MatroidIntersection.h} % spoko / do wytestowania

\section{DFS algorithms}
	\kactlimport{StronglyConnected.h} % spoko / do wytestowania
	\kactlimport{Biconnected.h} % spoko / do wytestowania
	\kactlimport{2Sat.h} % spoko / wytestowane
	\kactlimport{EulerWalk.h} % spoko / do wytestowania
	\kactlimport{Dominators.h} % potepa / do wytestowania
	\kactlimport{KthShortest.h} % potepa / do wytestowania
	\kactlimport{DenseDFS.h}
	\kactlimport{PlanarFaces.h}
	\kactlimport{PlanarityCheck.h}

\section{Coloring}
	\kactlimport{EdgeColoring.h}
	\kactlimport{EdgeColoringBipartite.h}
    \kactlimport{ChordalGraph.h}
	\kactlimport{ChromaticNumber.h}

\section{Heuristics}
	\kactlimport{MaximalCliques.h}
	\kactlimport{MaximumClique.h}
	\kactlimport{MaximumCliqueChinese.h}
	% \kactlimport{MaximumIndependentSet.h}

\section{Trees}
	% \kactlimport{TreeJumps.h}
	\kactlimport{LCA.h}
	% \kactlimport{CompressTree.h}
	\kactlimport{HLD.h}
	\kactlimport{Centroid.h}
	\kactlimport{LinkCutTree.h}
	\kactlimport{DirectedMST.h}

\section{Math}
	\subsection{Number of Spanning Trees}
		% I.e. matrix-tree theorem.
		% Source: https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem
		% Test: stress-tests/graph/matrix-tree.cpp
		Create an $N\times N$ matrix \texttt{mat}, and for each edge $a \rightarrow b \in G$, do
		\texttt{mat[a][b]--, mat[b][b]++} (and \texttt{mat[b][a]--, mat[a][a]++} if $G$ is undirected).
		Remove the $i$th row and column and take the determinant; this yields the number of directed spanning trees rooted at $i$
		(if $G$ is undirected, remove any row/column).

	\subsection{Erdős–Gallai theorem}
		% Source: https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem
		% Test: stress-tests/graph/erdos-gallai.cpp
		A simple graph with node degrees $d_1 \ge \dots \ge d_n$ exists iff $d_1 + \dots + d_n$ is even and for every $k = 1\dots n$,
		\[ \sum _{i=1}^{k}d_{i}\leq k(k-1)+\sum _{i=k+1}^{n}\min(d_{i},k). \]
